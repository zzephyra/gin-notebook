import "@blocknote/core/fonts/inter.css";
import { BlockNoteView } from "@blocknote/mantine";
import { Block, BlockNoteSchema, defaultInlineContentSpecs, filterSuggestionItems } from "@blocknote/core";
import "@blocknote/mantine/style.css";
import { BlockNoteOptions } from "./type";
import {
    AIMenuController,
    AIToolbarButton,
    createAIExtension,
    createBlockNoteAIClient,
    getAIExtension,
    getAISlashMenuItems,
} from "@blocknote/xl-ai"
// import { ComponentProps, useComponentsContext } from "@blocknote/react";
import "@blocknote/xl-ai/style.css";
// import {
//     DefaultThreadStoreAuth,
//     // YjsThreadStore,
//     RESTYjsThreadStore
// } from "@blocknote/core/comments";
import { createDeepSeek } from "@ai-sdk/deepseek";
import {
    FormattingToolbar,
    FormattingToolbarController,
    SuggestionMenuController,
    getDefaultReactSlashMenuItems,
    getFormattingToolbarItems,
    useCreateBlockNote,
} from "@blocknote/react";
import { i18n } from '@lingui/core';
import { useEffect, useRef, useState } from "react";
import { en as aiEn, zh as aiZh } from "@blocknote/xl-ai/locales";
import { en, zh } from "@blocknote/core/locales";
import { BASE_URL } from "@/lib/api/client";
import { aiChatApi } from "@/features/api/routes";
// import { YDocProvider } from "@y-sweet/react";
import type { User } from "@blocknote/core/comments";
import { getUserInfoByIDRequest } from "@/features/api/user";
import { diffSnapshots, flattenDocument } from "@/utils/blocksSnapshot";
import { PatchOp } from "@/types/note";
export type MyUserType = User & {
    role: "editor" | "comment";
};
const colors = [
    "#958DF1",
    "#F98181",
    "#FBBC88",
    "#FAF594",
    "#70CFF8",
    "#94FADB",
    "#B9F18D",
];

const getRandomElement = (list: any[]) =>
    list[Math.floor(Math.random() * list.length)];
export const getRandomColor = () => getRandomElement(colors);

const schema = BlockNoteSchema.create({
    inlineContentSpecs: {
        // Adds all default inline content.
        ...defaultInlineContentSpecs,
        // Adds the mention tag.
        // comment: commentMark,
    },

});

const localeMapping = {
    zh_cn: {
        ...zh, ai: aiZh
    },
    en: {
        ...en, ai: aiEn
    }
}

async function resolveUsers(userIds: string[]) {
    var res = await getUserInfoByIDRequest(userIds[0])
    if (res) {
        return [{
            id: res.id,
            username: res.nickname || res.email,
            avatarUrl: res.avatar,
        }]
    } else {
        return [{
            id: "0",
            username: "Unknown User",
            avatarUrl: "https://placehold.co/100x100?text=Unknown",
        }]
    }
}

const BlockNoteEditor = ({ noteID, content, onChange, options, className }: { noteID: string, content?: Block[], className?: string, onChange?: (value: PatchOp[]) => void, options?: BlockNoteOptions }) => {
    return (
        // <YDocProvider
        //     docId={noteID}
        //     authEndpoint="https://demos.y-sweet.dev/api/auth"
        // >
        <BlockNoteEditorInner options={options} noteID={noteID} content={content} onChange={onChange} className={className} />
        // </YDocProvider>

    )
}

function createMameosAIExtension() {
    const client = createBlockNoteAIClient({
        apiKey: "",
        baseURL: BASE_URL + aiChatApi,
    });

    const model = createDeepSeek({
        // call via our proxy client
        ...client.getProviderSettings("openai"),
        baseURL: BASE_URL + aiChatApi,
        fetch: async (_: RequestInfo | URL, init?: RequestInit) => {
            return fetch(`${BASE_URL}${aiChatApi}`, {
                method: "POST",
                credentials: "include",   // 关键！带上 Cookie
                headers: {
                    "Content-Type": "application/json",
                    Accept: "text/event-stream",
                },
                body: init?.body,
                signal: init?.signal,
            });
        }
    })("deepseek-r1-distill-llama-70b");
    var plugin = createAIExtension({
        model,
        stream: true
    })
    return plugin;
}


const BlockNoteEditorInner = ({ noteID, content, onChange, options, className }: { noteID: string, content?: Block[], onChange?: (value: PatchOp[]) => void, options?: BlockNoteOptions, className?: string }) => {
    // const client = createBlockNoteAIClient({
    //     apiKey: "PLACEHOLDER",
    //     baseURL: BASE_URL + aiChatApi,
    // });

    const [aiRecommand, setAiRecommand] = useState<any>(null);
    // const currentUser = useSelector((state: RootState) => {
    //     return {
    //         id: state.user.id,
    //         username: state.user.nickname || state.user.email,
    //         avatarUrl: state.user.avatar || "https://placehold.co/100x100?text=User",
    //         role: "editor" as const, // or "comment" based on your logic
    //     }
    // });

    const prevNoteId = useRef("");
    const prevContent = useRef<Block[]>();
    const editor = useCreateBlockNote(
        {
            dictionary: {
                ...localeMapping[i18n.locale as keyof typeof localeMapping] || localeMapping.en,
                placeholders: {
                    ...localeMapping[i18n.locale as keyof typeof localeMapping].placeholders,
                    // We override the empty document placeholder
                    emptyDocument: "Start typing..",
                    // We override the default placeholder
                    default: "Custom default placeholder",
                    // We override the heading placeholder
                    heading: "Custom heading placeholder",
                },
            },
            schema,
            extensions: [
                createMameosAIExtension(),
            ],
            resolveUsers,
            initialContent: content?.length == 0 ? [{ "type": "paragraph" }] : content,
        }, [noteID]);

    const handleOnChange = async () => {
        const markdownContent = editor.document;
        const flattened = flattenDocument(markdownContent);
        const diff = diffSnapshots(flattenDocument(prevContent.current || []), flattened);
        if (onChange) {
            onChange(diff);
        }
    }

    useEffect(() => {
        const unsubscribe = getAIExtension(editor).store.subscribe(() => {
            setAiRecommand((getAIExtension(editor).store.getState().aiMenuState as any).status);
        });
        return () => unsubscribe();
    }, [editor]);
    useEffect(() => {
        const noteIdChanged = prevNoteId.current !== noteID;
        const contentChanged = prevContent.current !== content;
        if ((noteIdChanged || contentChanged) && !aiRecommand) {
            prevNoteId.current = noteID;
            prevContent.current = content || [];
        }
    }, [content]);


    return (
        <>
            <BlockNoteView editor={editor}
                className={`h-full w-full ${className || ""}`}
                onChange={handleOnChange}
                formattingToolbar={false}
                editable={options?.editable !== false}
            >

                <AIMenuController />

                {/* We disabled the default formatting toolbar with `formattingToolbar=false` 
        and replace it for one with an "AI button" (defined below). 
        (See "Formatting Toolbar" in docs)
        */}
                <FormattingToolbarController
                    formattingToolbar={() => (
                        <FormattingToolbar>
                            {...getFormattingToolbarItems()}
                            <AIToolbarButton />
                            {/* <Popover placement="bottom" showArrow={true}>
                                <PopoverTrigger>
                                    <Button className="rounded min-h-0 min-w-0" size="sm" variant="light" radius="sm" isIconOnly>
                                        <ChatBubbleLeftEllipsisIcon className="w-4 h-4" />
                                    </Button>
                                </PopoverTrigger>
                                <PopoverContent>
                                    <CommentInput editor={editor as any} schema={schema} />
                                </PopoverContent>
                            </Popover> */}

                        </FormattingToolbar>
                    )}
                />
                <SuggestionMenuController
                    triggerCharacter="/"
                    getItems={async (query) =>
                        filterSuggestionItems(
                            [
                                ...getDefaultReactSlashMenuItems(editor),
                                ...getAISlashMenuItems(editor),
                            ],
                            query,
                        )
                    }
                />
            </BlockNoteView>
        </>
    )
}

export default BlockNoteEditor;